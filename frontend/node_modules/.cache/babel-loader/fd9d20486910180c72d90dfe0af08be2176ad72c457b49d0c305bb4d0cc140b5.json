{"ast":null,"code":"var _s = $RefreshSig$();\n// src/Cryptos/KrakenApiBugSolve.js\nimport { useEffect, useState } from \"react\";\nexport default function useKrakenPricesRest(pairs) {\n  _s();\n  const [prices, setPrices] = useState({});\n  useEffect(() => {\n    if (!pairs || pairs.length === 0) return;\n    const fetchPrices = async () => {\n      try {\n        const symbols = pairs.join(\",\");\n        const res = await fetch(`https://api.kraken.com/0/public/Ticker?pair=${symbols}`);\n        const data = await res.json();\n        if (data.error && data.error.length > 0) {\n          console.error(\"Kraken API error:\", data.error);\n          return;\n        }\n        const newPrices = {};\n        for (const key in data.result) {\n          var _data$result$key, _data$result$key$c;\n          // Kraken понякога връща например \"XXBTZUSD\" вместо \"BTC/USD\"\n          const priceStr = (_data$result$key = data.result[key]) === null || _data$result$key === void 0 ? void 0 : (_data$result$key$c = _data$result$key.c) === null || _data$result$key$c === void 0 ? void 0 : _data$result$key$c[0];\n          const priceNum = Number(priceStr);\n          if (Number.isFinite(priceNum)) {\n            // Намираме оригиналния символ от pairs, който отговаря на ключа\n            const matchedSymbol = pairs.find(sym => key.toUpperCase().includes(sym.toUpperCase()));\n            if (matchedSymbol) {\n              newPrices[matchedSymbol] = priceNum;\n            }\n          }\n        }\n        setPrices(newPrices);\n      } catch (err) {\n        console.error(\"Error fetching Kraken prices:\", err);\n      }\n    };\n    fetchPrices();\n\n    // Рефреш на цените на всеки 10 секунди\n    const interval = setInterval(fetchPrices, 10000);\n    return () => clearInterval(interval);\n  }, [pairs]);\n  return prices;\n}\n_s(useKrakenPricesRest, \"AyDZng7+aEBipOGwqaguTBzobZI=\");","map":{"version":3,"names":["useEffect","useState","useKrakenPricesRest","pairs","_s","prices","setPrices","length","fetchPrices","symbols","join","res","fetch","data","json","error","console","newPrices","key","result","_data$result$key","_data$result$key$c","priceStr","c","priceNum","Number","isFinite","matchedSymbol","find","sym","toUpperCase","includes","err","interval","setInterval","clearInterval"],"sources":["C:/Users/User/Documents/Trading212/TradingSimulation/frontend/src/OtherPages/CryptoTable.jsx"],"sourcesContent":["// src/Cryptos/KrakenApiBugSolve.js\r\nimport { useEffect, useState } from \"react\";\r\n\r\nexport default function useKrakenPricesRest(pairs) {\r\n    const [prices, setPrices] = useState({});\r\n\r\n    useEffect(() => {\r\n        if (!pairs || pairs.length === 0) return;\r\n\r\n        const fetchPrices = async () => {\r\n            try {\r\n                const symbols = pairs.join(\",\");\r\n                const res = await fetch(`https://api.kraken.com/0/public/Ticker?pair=${symbols}`);\r\n                const data = await res.json();\r\n\r\n                if (data.error && data.error.length > 0) {\r\n                    console.error(\"Kraken API error:\", data.error);\r\n                    return;\r\n                }\r\n\r\n                const newPrices = {};\r\n                for (const key in data.result) {\r\n                    // Kraken понякога връща например \"XXBTZUSD\" вместо \"BTC/USD\"\r\n                    const priceStr = data.result[key]?.c?.[0];\r\n                    const priceNum = Number(priceStr);\r\n                    if (Number.isFinite(priceNum)) {\r\n                        // Намираме оригиналния символ от pairs, който отговаря на ключа\r\n                        const matchedSymbol = pairs.find(sym => key.toUpperCase().includes(sym.toUpperCase()));\r\n                        if (matchedSymbol) {\r\n                            newPrices[matchedSymbol] = priceNum;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                setPrices(newPrices);\r\n            } catch (err) {\r\n                console.error(\"Error fetching Kraken prices:\", err);\r\n            }\r\n        };\r\n\r\n        fetchPrices();\r\n\r\n        // Рефреш на цените на всеки 10 секунди\r\n        const interval = setInterval(fetchPrices, 10000);\r\n        return () => clearInterval(interval);\r\n\r\n    }, [pairs]);\r\n\r\n    return prices;\r\n}\r\n"],"mappings":";AAAA;AACA,SAASA,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAE3C,eAAe,SAASC,mBAAmBA,CAACC,KAAK,EAAE;EAAAC,EAAA;EAC/C,MAAM,CAACC,MAAM,EAAEC,SAAS,CAAC,GAAGL,QAAQ,CAAC,CAAC,CAAC,CAAC;EAExCD,SAAS,CAAC,MAAM;IACZ,IAAI,CAACG,KAAK,IAAIA,KAAK,CAACI,MAAM,KAAK,CAAC,EAAE;IAElC,MAAMC,WAAW,GAAG,MAAAA,CAAA,KAAY;MAC5B,IAAI;QACA,MAAMC,OAAO,GAAGN,KAAK,CAACO,IAAI,CAAC,GAAG,CAAC;QAC/B,MAAMC,GAAG,GAAG,MAAMC,KAAK,CAAC,+CAA+CH,OAAO,EAAE,CAAC;QACjF,MAAMI,IAAI,GAAG,MAAMF,GAAG,CAACG,IAAI,CAAC,CAAC;QAE7B,IAAID,IAAI,CAACE,KAAK,IAAIF,IAAI,CAACE,KAAK,CAACR,MAAM,GAAG,CAAC,EAAE;UACrCS,OAAO,CAACD,KAAK,CAAC,mBAAmB,EAAEF,IAAI,CAACE,KAAK,CAAC;UAC9C;QACJ;QAEA,MAAME,SAAS,GAAG,CAAC,CAAC;QACpB,KAAK,MAAMC,GAAG,IAAIL,IAAI,CAACM,MAAM,EAAE;UAAA,IAAAC,gBAAA,EAAAC,kBAAA;UAC3B;UACA,MAAMC,QAAQ,IAAAF,gBAAA,GAAGP,IAAI,CAACM,MAAM,CAACD,GAAG,CAAC,cAAAE,gBAAA,wBAAAC,kBAAA,GAAhBD,gBAAA,CAAkBG,CAAC,cAAAF,kBAAA,uBAAnBA,kBAAA,CAAsB,CAAC,CAAC;UACzC,MAAMG,QAAQ,GAAGC,MAAM,CAACH,QAAQ,CAAC;UACjC,IAAIG,MAAM,CAACC,QAAQ,CAACF,QAAQ,CAAC,EAAE;YAC3B;YACA,MAAMG,aAAa,GAAGxB,KAAK,CAACyB,IAAI,CAACC,GAAG,IAAIX,GAAG,CAACY,WAAW,CAAC,CAAC,CAACC,QAAQ,CAACF,GAAG,CAACC,WAAW,CAAC,CAAC,CAAC,CAAC;YACtF,IAAIH,aAAa,EAAE;cACfV,SAAS,CAACU,aAAa,CAAC,GAAGH,QAAQ;YACvC;UACJ;QACJ;QAEAlB,SAAS,CAACW,SAAS,CAAC;MACxB,CAAC,CAAC,OAAOe,GAAG,EAAE;QACVhB,OAAO,CAACD,KAAK,CAAC,+BAA+B,EAAEiB,GAAG,CAAC;MACvD;IACJ,CAAC;IAEDxB,WAAW,CAAC,CAAC;;IAEb;IACA,MAAMyB,QAAQ,GAAGC,WAAW,CAAC1B,WAAW,EAAE,KAAK,CAAC;IAChD,OAAO,MAAM2B,aAAa,CAACF,QAAQ,CAAC;EAExC,CAAC,EAAE,CAAC9B,KAAK,CAAC,CAAC;EAEX,OAAOE,MAAM;AACjB;AAACD,EAAA,CA9CuBF,mBAAmB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}