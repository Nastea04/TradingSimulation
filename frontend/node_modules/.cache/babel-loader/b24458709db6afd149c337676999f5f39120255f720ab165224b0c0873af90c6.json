{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useState, useRef, useMemo } from \"react\";\nexport default function useKrakenPrices2(pairs) {\n  _s();\n  const [prices, setPrices] = useState({});\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const heartbeatIntervalRef = useRef(null);\n  const retryDelayRef = useRef(3000);\n  const isUnmountedRef = useRef(false);\n\n  // стабилизираме масива с useMemo\n  const stablePairs = useMemo(() => Array.isArray(pairs) ? pairs : [pairs], [JSON.stringify(pairs)]);\n  const startHeartbeat = (ws, intervalMs = 15000) => {\n    clearInterval(heartbeatIntervalRef.current);\n    heartbeatIntervalRef.current = setInterval(() => {\n      if (ws.readyState === WebSocket.OPEN) {\n        ws.send(JSON.stringify({\n          method: \"ping\"\n        }));\n      }\n    }, intervalMs);\n  };\n  const stopHeartbeat = () => {\n    clearInterval(heartbeatIntervalRef.current);\n    heartbeatIntervalRef.current = null;\n  };\n  const connect = () => {\n    if (isUnmountedRef.current) return;\n\n    // чистим евентуален стар reconnect\n    clearTimeout(reconnectTimeoutRef.current);\n    const ws = new WebSocket(\"wss://ws.kraken.com/v2\");\n    wsRef.current = ws;\n    ws.onopen = () => {\n      console.log(\"✅ Connected to Kraken\");\n      retryDelayRef.current = 3000;\n      ws.send(JSON.stringify({\n        method: \"subscribe\",\n        params: {\n          channel: \"ticker\",\n          symbol: stablePairs\n        }\n      }));\n      startHeartbeat(ws, 15000);\n    };\n    ws.onmessage = event => {\n      try {\n        const msg = JSON.parse(event.data);\n        if (msg.channel === \"ticker\" && (msg.type === \"snapshot\" || msg.type === \"update\")) {\n          msg.data.forEach(ticker => {\n            setPrices(prev => ({\n              ...prev,\n              [ticker.symbol]: ticker.last\n            }));\n          });\n        }\n      } catch (err) {\n        console.error(\"❌ Parse error:\", err);\n      }\n    };\n    ws.onerror = () => {\n      console.error(\"⚠️ WebSocket error\");\n    };\n    ws.onclose = event => {\n      console.warn(`⚠️ Closed: code=${event.code}, reason=${event.reason || \"No reason\"}`);\n      stopHeartbeat();\n      if (!isUnmountedRef.current && event.code !== 1000) {\n        console.log(`🔄 Reconnecting in ${retryDelayRef.current / 1000}s...`);\n        reconnectTimeoutRef.current = setTimeout(connect, retryDelayRef.current);\n        retryDelayRef.current = Math.min(retryDelayRef.current * 2, 60000);\n      }\n    };\n  };\n  useEffect(() => {\n    connect();\n    return () => {\n      isUnmountedRef.current = true;\n      clearTimeout(reconnectTimeoutRef.current);\n      stopHeartbeat();\n      if (wsRef.current) wsRef.current.close();\n    };\n  }, [stablePairs]);\n  return prices;\n}\n_s(useKrakenPrices2, \"X0mNTzP1obMjz5K+BaE8svApMG8=\");","map":{"version":3,"names":["useEffect","useState","useRef","useMemo","useKrakenPrices2","pairs","_s","prices","setPrices","wsRef","reconnectTimeoutRef","heartbeatIntervalRef","retryDelayRef","isUnmountedRef","stablePairs","Array","isArray","JSON","stringify","startHeartbeat","ws","intervalMs","clearInterval","current","setInterval","readyState","WebSocket","OPEN","send","method","stopHeartbeat","connect","clearTimeout","onopen","console","log","params","channel","symbol","onmessage","event","msg","parse","data","type","forEach","ticker","prev","last","err","error","onerror","onclose","warn","code","reason","setTimeout","Math","min","close"],"sources":["C:/Users/User/Documents/Trading212/TradingSimulation/frontend/src/Cryptos/KrakenApi.js"],"sourcesContent":["import { useEffect, useState, useRef, useMemo } from \"react\";\r\n\r\nexport default function useKrakenPrices2(pairs) {\r\n    const [prices, setPrices] = useState({});\r\n    const wsRef = useRef(null);\r\n    const reconnectTimeoutRef = useRef(null);\r\n    const heartbeatIntervalRef = useRef(null);\r\n    const retryDelayRef = useRef(3000);\r\n    const isUnmountedRef = useRef(false);\r\n\r\n    // стабилизираме масива с useMemo\r\n    const stablePairs = useMemo(() => Array.isArray(pairs) ? pairs : [pairs], [JSON.stringify(pairs)]);\r\n\r\n    const startHeartbeat = (ws, intervalMs = 15000) => {\r\n        clearInterval(heartbeatIntervalRef.current);\r\n        heartbeatIntervalRef.current = setInterval(() => {\r\n            if (ws.readyState === WebSocket.OPEN) {\r\n                ws.send(JSON.stringify({ method: \"ping\" }));\r\n            }\r\n        }, intervalMs);\r\n    };\r\n\r\n    const stopHeartbeat = () => {\r\n        clearInterval(heartbeatIntervalRef.current);\r\n        heartbeatIntervalRef.current = null;\r\n    };\r\n\r\n    const connect = () => {\r\n        if (isUnmountedRef.current) return;\r\n\r\n        // чистим евентуален стар reconnect\r\n        clearTimeout(reconnectTimeoutRef.current);\r\n\r\n        const ws = new WebSocket(\"wss://ws.kraken.com/v2\");\r\n        wsRef.current = ws;\r\n\r\n        ws.onopen = () => {\r\n            console.log(\"✅ Connected to Kraken\");\r\n\r\n            retryDelayRef.current = 3000;\r\n\r\n            ws.send(JSON.stringify({\r\n                method: \"subscribe\",\r\n                params: {\r\n                    channel: \"ticker\",\r\n                    symbol: stablePairs\r\n                }\r\n            }));\r\n\r\n            startHeartbeat(ws, 15000);\r\n        };\r\n\r\n        ws.onmessage = (event) => {\r\n            try {\r\n                const msg = JSON.parse(event.data);\r\n                if (msg.channel === \"ticker\" && (msg.type === \"snapshot\" || msg.type === \"update\")) {\r\n                    msg.data.forEach(ticker => {\r\n                        setPrices(prev => ({\r\n                            ...prev,\r\n                            [ticker.symbol]: ticker.last\r\n                        }));\r\n                    });\r\n                }\r\n            } catch (err) {\r\n                console.error(\"❌ Parse error:\", err);\r\n            }\r\n        };\r\n\r\n        ws.onerror = () => {\r\n            console.error(\"⚠️ WebSocket error\");\r\n        };\r\n\r\n        ws.onclose = (event) => {\r\n            console.warn(`⚠️ Closed: code=${event.code}, reason=${event.reason || \"No reason\"}`);\r\n\r\n            stopHeartbeat();\r\n\r\n            if (!isUnmountedRef.current && event.code !== 1000) {\r\n                console.log(`🔄 Reconnecting in ${retryDelayRef.current / 1000}s...`);\r\n                reconnectTimeoutRef.current = setTimeout(connect, retryDelayRef.current);\r\n                retryDelayRef.current = Math.min(retryDelayRef.current * 2, 60000);\r\n            }\r\n        };\r\n    };\r\n\r\n    useEffect(() => {\r\n        connect();\r\n        return () => {\r\n            isUnmountedRef.current = true;\r\n            clearTimeout(reconnectTimeoutRef.current);\r\n            stopHeartbeat();\r\n            if (wsRef.current) wsRef.current.close();\r\n        };\r\n    }, [stablePairs]);\r\n\r\n    return prices;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}